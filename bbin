#!/usr/bin/env bb

; :bbin/start
;
; {:coords {:bbin/url "https://raw.githubusercontent.com/babashka/bbin/v0.2.4/bbin"}}
;
; :bbin/end

(babashka.deps/add-deps
  '{:deps {selmer/selmer {:mvn/version "1.12.55"},
           expound/expound {:mvn/version "0.9.0"},
           fipp/fipp {:mvn/version "0.6.26"},
           org.babashka/cli {:mvn/version "0.6.43"},
           com.taoensso/timbre {:mvn/version "5.2.1"},
           babashka/process {:mvn/version "0.4.14"},
           org.clojure/tools.gitlibs {:mvn/version "2.4.181"},
           org.babashka/http-client {:mvn/version "0.1.8"},
           version-clj/version-clj {:mvn/version "2.0.2"},
           babashka/fs {:mvn/version "0.3.17"},
           org.babashka/json {:mvn/version "0.1.1"}}})

(ns babashka.bbin.meta)
(def min-bb-version "This def was generated by the bbin build script." "0.9.162")
(def version "This def was generated by the bbin build script." "0.2.4")
(ns babashka.bbin.dirs
  (:require [babashka.fs :as fs]
            [clojure.string :as str]))

(defn user-home []
  (System/getProperty "user.home"))

(defn print-legacy-path-warning []
  (binding [*out* *err*]
    (println (str/triml "
WARNING: In bbin 0.2.0, we now use the XDG Base Directory Specification by
WARNING: default. This means the ~/.babashka/bbin/bin path is deprecated in
WARNING: favor of ~/.local/bin.
WARNING:
WARNING: To remove this message, run `bbin migrate` for further instructions.
WARNING: (We won't make any changes without asking you first.)
"))))

(def ^:dynamic *legacy-bin-dir* nil)

(defn- legacy-override-dir []
  (some-> (or (System/getenv "BABASHKA_BBIN_DIR")
              (some-> (System/getenv "XDG_DATA_HOME") (fs/file ".babashka" "bbin")))
          (fs/canonicalize {:nofollow-links true})))

(defn legacy-bin-dir-base []
  (if-let [override (legacy-override-dir)]
    (fs/file override "bin")
    (fs/file (user-home) ".babashka" "bbin" "bin")))

(defn legacy-bin-dir []
  (or *legacy-bin-dir* (legacy-bin-dir-base)))

(defn using-legacy-paths? []
  (fs/exists? (legacy-bin-dir)))

(def ^:dynamic *legacy-jars-dir* nil)

(defn legacy-jars-dir-base []
  (if-let [override (legacy-override-dir)]
    (fs/file override "jars")
    (fs/file (user-home) ".babashka" "bbin" "jars")))

(defn legacy-jars-dir []
  (or *legacy-jars-dir* (legacy-jars-dir-base)))

(defn check-legacy-paths []
  (when (using-legacy-paths?)
    (print-legacy-path-warning)))

(def ^:dynamic *xdg-bin-dir* nil)

(defn xdg-bin-dir [_]
  (or *xdg-bin-dir*
      (if-let [override (System/getenv "BABASHKA_BBIN_BIN_DIR")]
        (fs/file (fs/expand-home override))
        (fs/file (user-home) ".local" "bin"))))

(defn bin-dir [opts]
  (if (using-legacy-paths?)
    (legacy-bin-dir)
    (xdg-bin-dir opts)))

(def ^:dynamic *xdg-jars-dir* nil)

(defn xdg-jars-dir [_]
  (or *xdg-jars-dir*
      (if-let [override (System/getenv "BABASHKA_BBIN_JARS_DIR")]
        (fs/file (fs/expand-home override))
        (fs/file (fs/xdg-cache-home) "babashka" "bbin" "jars"))))

(defn jars-dir [opts]
  (if (using-legacy-paths?)
    (legacy-jars-dir)
    (xdg-jars-dir opts)))

(defn ensure-bbin-dirs [cli-opts]
  (fs/create-dirs (bin-dir cli-opts)))

(defn ensure-xdg-dirs [cli-opts]
  (fs/create-dirs (xdg-bin-dir cli-opts))
  (fs/create-dirs (xdg-jars-dir cli-opts)))

(ns babashka.bbin.git
  (:require [babashka.fs :as fs]
            [babashka.process :refer [sh]]
            [clojure.string :as str]))

(defn- ensure-git-dir [client git-url]
  (binding [*err* (java.io.StringWriter.)]
    (let [path ((:ensure-git-dir client) git-url)]
      ((:git-fetch client) (fs/file path))
      path)))

(defn default-branch [client git-url]
  (let [lib-dir (ensure-git-dir client git-url)
        remote-info (sh "git remote show origin" {:dir lib-dir
                                                  :extra-env {"LC_ALL" "C"}})
        [[_ branch]] (->> (:out remote-info)
                          str/split-lines
                          (some #(re-seq #"HEAD branch: (\w+)" %)))]
    branch))

(defn latest-git-sha [client git-url]
  (let [lib-dir (ensure-git-dir client git-url)
        branch (default-branch client git-url)
        log-result (sh ["git" "log" "-n" "1" branch "--pretty=format:%H"]
                       {:dir lib-dir})]
    (str/trim-newline (:out log-result))))

(defn find-git-tag [client git-url tag]
  (let [lib-dir (ensure-git-dir client git-url)
        log-result (sh ["git" "log" "-n" "1" tag "--pretty=format:%H"]
                       {:dir lib-dir})
        sha (str/trim-newline (:out log-result))]
    {:name (str tag)
     :commit {:sha sha}}))

(defn latest-git-tag [client git-url]
  (let [lib-dir (ensure-git-dir client git-url)
        describe-result (sh "git describe --tags --abbrev=0" {:dir lib-dir})
        tag (str/trim-newline (:out describe-result))]
    (when-not (str/blank? tag)
      (find-git-tag client git-url tag))))

(def providers
  {#"^(com|io)\.github\." :github
   #"^(com|io)\.gitlab\." :gitlab
   #"^(org|io)\.bitbucket\." :bitbucket
   #"^(com|io)\.beanstalkapp\." :beanstalk
   #"^ht\.sr\." :sourcehut})

(defn- clean-lib-str [lib]
  (->> (reduce #(str/replace %1 %2 "") lib (keys providers))
       symbol))

(defn git-http-url [lib]
  (let [provider (some #(when (re-seq (key %) (str lib)) %) providers)
        s (clean-lib-str (str lib))]
    (case (val provider)
      :github (str "https://github.com/" s ".git")
      :gitlab (str "https://gitlab.com/" s ".git")
      :bitbucket (let [[u] (str/split (str s) #"/")]
                   (str "https://" u "@bitbucket.org/" s ".git"))
      :beanstalk (let [[u] (str/split (str s) #"/")]
                   (str "https://" u ".git.beanstalkapp.com/" (name lib) ".git"))
      :sourcehut (str "https://git.sr.ht/~" s))))

(defn git-ssh-url [lib]
  (let [provider (some #(when (re-seq (key %) (str lib)) %) providers)
        s (clean-lib-str (str lib))]
    (case (val provider)
      :github (str "git@github.com:" s ".git")
      :gitlab (str "git@gitlab.com:" s ".git")
      :bitbucket (str "git@bitbucket.org:" s ".git")
      :beanstalk (let [[u] (str/split (str s) #"/")]
                   (str "git@" u ".git.beanstalkapp.com:/" s ".git"))
      :sourcehut (str "git@git.sr.ht:~" s))))

(defn git-repo-url [client lib]
  (try
    (let [url (git-http-url lib)]
      (ensure-git-dir client url)
      url)
    (catch Exception e
      (if (re-seq #"^Unable to clone " (ex-message e))
        (let [url (git-ssh-url lib)]
          (ensure-git-dir client url)
          url)
        (throw e)))))

(ns babashka.bbin.deps
  (:require [babashka.bbin.git :as git]
            [babashka.fs :as fs]
            [clojure.edn :as edn]
            [clojure.set :as set]
            [clojure.string :as str]
            [clojure.tools.gitlibs.impl :as gitlibs-impl]))

(def lib-opts->template-deps-fn
  "A map to define valid CLI options.

  - Each key is a sequence of valid combinations of CLI opts.
  - Each value is a function which returns a tools.deps lib map."
  {[#{:local/root}]
   (fn [_ lib-sym lib-opts]
     {lib-sym (select-keys lib-opts [:local/root])})

   [#{} #{:git/url}]
   (fn [client lib-sym lib-opts]
     (let [url (or (:git/url lib-opts) (git/git-repo-url client lib-sym))
           tag (git/latest-git-tag client url)]
       (if tag
         {lib-sym {:git/url url
                   :git/tag (:name tag)
                   :git/sha (-> tag :commit :sha)}}
         (let [sha (git/latest-git-sha client url)]
           {lib-sym {:git/url url
                     :git/sha sha}}))))

   [#{:git/tag} #{:git/url :git/tag}]
   (fn [client lib-sym lib-opts]
     (let [url (or (:git/url lib-opts) (git/git-repo-url client lib-sym))
           tag (:git/tag lib-opts)
           {:keys [commit]} (git/find-git-tag client url tag)]
       {lib-sym {:git/url url
                 :git/tag tag
                 :git/sha (:sha commit)}}))

   [#{:git/sha} #{:git/url :git/sha}]
   (fn [client lib-sym lib-opts]
     (let [url (or (:git/url lib-opts) (git/git-repo-url client lib-sym))
           sha (:git/sha lib-opts)]
       {lib-sym {:git/url url
                 :git/sha sha}}))

   [#{:latest-sha} #{:git/url :latest-sha}]
   (fn [client lib-sym lib-opts]
     (let [url (or (:git/url lib-opts) (git/git-repo-url client lib-sym))
           sha (git/latest-git-sha client url)]
       {lib-sym {:git/url url
                 :git/sha sha}}))

   [#{:git/url :git/tag :git/sha}]
   (fn [_ lib-sym lib-opts]
     {lib-sym (select-keys lib-opts [:git/url :git/tag :git/sha])})})

(def valid-lib-opts
  "The set of all valid combinations of CLI opts."
  (into #{} cat (keys lib-opts->template-deps-fn)))

(defn- cli-opts->lib-opts
  "Returns parsed lib opts from raw CLI opts."
  [cli-opts]
  (-> cli-opts
      (set/rename-keys {:sha :git/sha})
      (select-keys (into #{} cat valid-lib-opts))))

(defn- find-template-deps-fn
  "Returns a template-deps-fn given lib-opts parsed from raw CLI opts."
  [lib-opts]
  (some (fn [[k v]] (and (contains? (set k) (set (keys lib-opts))) v))
        lib-opts->template-deps-fn))

(defn- invalid-lib-opts-error [provided-lib-opts]
  (ex-info (str "Provided invalid combination of CLI options")
           {:provided-opts (set (keys provided-lib-opts))
            :valid-combinations valid-lib-opts}))

(def ^:private default-deps-info-client
  {:ensure-git-dir gitlibs-impl/ensure-git-dir
   :git-fetch gitlibs-impl/git-fetch})

(defn infer
  "Returns a tools.deps lib map for the given CLI opts."
  ([cli-opts] (infer nil cli-opts))
  ([client cli-opts]
   (let [client (merge default-deps-info-client client)
         lib-opts (cli-opts->lib-opts cli-opts)
         lib-sym (edn/read-string (:lib cli-opts))
         template-deps-fn (find-template-deps-fn lib-opts)]
     (if-not template-deps-fn
       (throw (invalid-lib-opts-error lib-opts))
       (template-deps-fn client lib-sym lib-opts)))))

(def ^:private symbol-regex
  (re-pattern
   (str "(?i)^"
        "(?:((?:[a-z0-9-]+\\.)*[a-z0-9-]+)/)?"
        "((?:[a-z0-9-]+\\.)*[a-z0-9-]+)"
        "$")))

(defn- lib-str? [x]
  (boolean (and (string? x) (re-seq symbol-regex x))))

(defn- local-script-path? [x]
  (boolean (and (string? x) (or (fs/exists? x)
                                (fs/exists? (str/replace x #"^file://" ""))))))

(defn- http-url? [x]
  (boolean (and (string? x) (re-seq #"^https?://" x))))

(defn- git-ssh-url? [x]
  (boolean (and (string? x) (re-seq #"^.+@.+:.+\.git$" x))))

(defn- git-http-url? [x]
  (boolean (and (string? x) (re-seq #"^https?://.+\.git$" x))))

(defn git-repo-url? [s]
  (or (git-http-url? s) (git-ssh-url? s)))

(def ^:private deps-types
  [{:lib lib-str?
    :coords #{:local/root}
    :procurer :local}

   {:lib lib-str?
    :coords #{:mvn/version}
    :procurer :maven}

   {:lib local-script-path?
    :coords #{:bbin/url}
    :procurer :local}

   {:lib #(or (git-http-url? %) (git-ssh-url? %))
    :coords #{:bbin/url}
    :procurer :git}

   {:lib http-url?
    :coords #{:bbin/url}
    :procurer :http}

   {:lib lib-str?
    :coords #{:git/sha :git/url :git/tag}
    :procurer :git}

   {:lib local-script-path?
    :coords #{}
    :procurer :local}

   {:lib #(or (git-http-url? %) (git-ssh-url? %) (lib-str? %))
    :coords #{}
    :procurer :git}

   {:lib http-url?
    :coords #{}
    :procurer :http}])

(defn- deps-type-match? [cli-opts deps-type]
  (and ((:lib deps-type) (:script/lib cli-opts))
       (or (empty? (:coords deps-type))
           (seq (set/intersection (:coords deps-type) (set (keys cli-opts)))))
       deps-type))

(defn- match-deps-type [cli-opts]
  (or (some #(deps-type-match? cli-opts %) deps-types)
      {:procurer :unknown-procurer}))

(defn directory? [x]
  (fs/directory? (str/replace x #"^file://" "")))

(defn regular-file? [x]
  (fs/regular-file? (str/replace x #"^file://" "")))

(defn- match-artifact [cli-opts procurer]
  (cond
    (or (#{:maven} procurer)
        (and (#{:local} procurer)
             (or (and (:script/lib cli-opts) (re-seq #"\.jar$" (:script/lib cli-opts)))
                 (and (:local/root cli-opts) (re-seq #"\.jar$" (:local/root cli-opts)))))
        (and (#{:http} procurer) (re-seq #"\.jar$" (:script/lib cli-opts))))
    :jar

    (or (#{:git} procurer)
        (and (#{:local} procurer)
             (or (and (:script/lib cli-opts)
                      (directory? (:script/lib cli-opts)))
                 (and (:local/root cli-opts) (directory? (:local/root cli-opts)))))
        (and (#{:http} procurer) (re-seq #"\.git$" (:script/lib cli-opts))))
    :dir

    (or (and (#{:local} procurer) (and (:script/lib cli-opts)
                                       (regular-file? (:script/lib cli-opts))))
        (and (#{:http} procurer) (re-seq #"\.(cljc?|bb)$" (:script/lib cli-opts))))
    :file

    :else :unknown-artifact))

(defn summary [cli-opts]
  (let [{:keys [procurer]} (match-deps-type cli-opts)
        artifact (match-artifact cli-opts procurer)]
    {:procurer procurer
     :artifact artifact}))

(ns babashka.bbin.protocols)

(defprotocol Script
  (install [script])
  (upgrade [script])
  (uninstall [script]))

(ns babashka.bbin.meta)

;; This is a fallback if the var hasn't already been set earlier by a build
;; script, such as when bbin is called as a library instead of a script.
(defonce min-bb-version :version-not-set)
(defonce version :version-not-set)

(ns babashka.bbin.specs
  (:require [clojure.spec.alpha :as s]))

(s/def ::ns-default symbol?)
(s/def ::main-opts (s/coll-of string?))
(s/def ::script-config (s/keys :opt-un [::main-opts ::ns-default]))
(s/def :bbin/bin (s/map-of symbol? ::script-config))

(ns babashka.bbin.util
  (:require [babashka.bbin.meta :as meta]
            [babashka.fs :as fs]
            [babashka.process :as p]
            [clojure.edn :as edn]
            [clojure.pprint :as pprint]
            [clojure.string :as str]
            [taoensso.timbre :as log])
  (:import (java.time Instant)))

(def ^:dynamic *now* nil)

(defn now []
  (or *now* (Instant/now)))

(defn canonicalized-cli-opts [cli-opts]
  (merge cli-opts
         (when-let [v (:local/root cli-opts)]
           {:local/root (str (fs/canonicalize v {:nofollow-links true}))})))

(defn is-tty
  [fd key]
  (-> ["test" "-t" (str fd)]
      (p/process {key :inherit :env {}})
      deref
      :exit
      (= 0)))

(def tty-out? (memoize #(is-tty 1 :out)))

(defn terminal-dimensions
  "Yields e.g. `{:cols 30 :rows 120}`"
  []
  (->
   (p/process ["stty" "size"] {:inherit true :out :string})
   deref
   :out
   str/trim
   (str/split #" ")
   (->> (map #(Integer/parseInt %))
        (zipmap [:rows :cols]))))

(defn sh [cmd & {:as opts}]
  (doto (p/sh cmd (merge {:err :inherit} opts))
    p/check))

(defn set-logging-config! [{:keys [debug]}]
  (log/merge-config! {:min-level (if debug :debug :warn)}))

(defn pprint [x & _]
  (binding [*print-namespace-maps* false]
    (pprint/pprint x)))

(defn upgrade-enabled? []
  (some-> (System/getenv "BABASHKA_BBIN_FLAG_UPGRADE")
          edn/read-string))

(defn truncate
  "Truncates `s` when it exceeds length `truncate-to` by inserting `omission` at the given `omission-position`.

  The result's length will equal `truncate-to`, unless `truncate-to` < `omission`-length, in which case the result equals `omission`.

  Examples:
  ```clojure
  (truncate \"1234567\" {:truncate-to 7})
  # => \"1234567\"

  (truncate \"1234567\" {:truncate-to 5})
  # => \"12...\"

  (truncate \"1234567\" {:truncate-to 5 :omission \"(continued)\"})
  # => \"(continued)\"

  (truncate \"example.org/path/to/release/v1.2.3/server.jar\"
    {:omission \"…\" :truncate-to 35 :omission-position :center})
  # => \"example.org/path/…v1.2.3/server.jar\"
  ```

  Options:
  - `truncate-to` (`30`) length above which truncating will occur. The resulting string will have this length (assuming `(> truncate-to (count omission))`).
  - `omission` (`\"...\"`) what to use as omission.
  - `omission-position` (`:end`) where to put omission. Options: `#{:center :end}`.
  "
  [s {:keys [omission truncate-to omission-position]
      :or   {omission "..." truncate-to 30 omission-position :end}}]
  (if-not (> (count s) truncate-to)
    s
    (let [truncated-s-length  (max 0 (- truncate-to (count omission)))
          [lsub-len rsub-len] (case omission-position
                                :end    [truncated-s-length 0]
                                :center (if (even? truncated-s-length)
                                          [(/ truncated-s-length 2) (/ truncated-s-length 2)]
                                          [(/ (inc truncated-s-length) 2) (/ (dec truncated-s-length) 2)]))]
      (str (subs s 0 lsub-len)
           omission
           (subs s (- (count s) rsub-len) (count s))))))

(defn plain-mode? [{:keys [plain] :as _cli-opts}]
  (or (fs/windows?) plain (not (tty-out?))))

(defn no-color? [{:keys [color] :as cli-opts}]
  (or (false? color)
      (plain-mode? cli-opts)
      (System/getenv "NO_COLOR")
      (= "dumb" (System/getenv "TERM"))))

(defn bold [s cli-opts]
  (if (no-color? cli-opts) s (str "\033[1m" s "\033[0m")))

(defn printable-scripts [scripts]
  (map (fn [[bin {{lroot :local/root
                   gtag  :git/tag
                   gsha  :git/sha
                   gurl  :git/url
                   burl  :bbin/url} :coords}]]
         (cond-> (assoc {} :bin bin)
           gurl  (assoc :location gurl)
           burl  (assoc :location burl)
           lroot (assoc :location (str "file://" lroot))
           gsha  (assoc :version gsha)
           gtag  (assoc :version gtag)))
       scripts))

(defn print-table
  "Print table to stdout.

  Examples:
  ```clojure
  ;; Extract columns from rows
  (print-table [{:a \"one\" :b \"two\"}])

  a    b
  ───  ───
  one  two

  ;; Provide columns (as b is an empty column, it will be skipped)
  (print-table [:a :b] [{:a \"one\" :b nil}])

  a
  ───
  one

  ;; Ensure all columns being shown:
  (print-table [:a :b] [{:a \"one\"}] {:show-empty-columns true})

  ;; Provide columns with labels and apply column coercion
  (print-table {:a \"option A\" :b \"option B\"} [{:a \"one\" :b nil}]
               {:column-coercions {:b (fnil boolean false)}})

  option A  option B
  ────────  ────────
  one       false

  ;; Provide `max-width` and `:width-reduce-column` to try to make the table fit smaller screens.
  (print-table {:a \"123456\"} {:max-width 5 :width-reduce-column :a})

  a
  ─────
  12...

  ;; A custom `width-reduce-fn` can be provided. See options for details.
  (print-table {:a \"123456\"} {:max-width 5
                                :width-reduce-column :a
                                :width-reduce-fn #(subs %1 0 %2)})
  a
  ─────
  12345

  ```

  Options:
  - `column-coercions` (`{}`) fn that given a key `k` yields an fn to be applied to every `(k row)` *iff* row contains key `k`.
    See example above.
  - `skip-header` (`false`) don't print column names and divider (typically use this when stdout is no tty).
  - `show-empty-columns` (`false`) print every column, even if it results in empty columns.
  - `no-color` (`false`) prevent printing escape characters to stdout.
  - `max-width` (`nil`) when width of the table exceeds this value, `width-reduce-fn` will be applied to all cells of column `width-reduce-column`. NOTE: providing this, requires `width-reduce-column` to be provided as well.
  - `width-reduce-column` (`nil`) column that `width-reduce-fn` will be applied to when table width exceeds `max-width`.
  - `width-reduce-fn` (`#(truncate %1 {:truncate-to %2})`) function that is applied to all cells of column `width-reduce-column` when the table exceeds width `max-width`.
    The function should have 2-arity: a string (representing the cell value) and an integer (representing the max size of the cell contents in order for the table to stay within `max-width`)."
  ([rows]
   (print-table rows {}))
  ([ks-rows rows-opts]
   (let [rows->ks       #(-> % first keys)
         [ks rows opts] (if (map? rows-opts)
                          [(rows->ks ks-rows) ks-rows rows-opts]
                          [ks-rows rows-opts {}])]
     (print-table ks rows opts)))
  ([ks rows {:as   opts
             :keys [show-empty-columns skip-header no-color column-coercions
                    max-width width-reduce-column width-reduce-fn]
             :or   {show-empty-columns false skip-header false no-color false column-coercions {}}}]
   (assert (or (not max-width) (and max-width ((set ks) width-reduce-column)))
           (str "Option :max-width requires option :width-reduce-column to be one of " (pr-str ks)))
   (let [wrap-bold            (fn [s] (if no-color s (str "\033[1m" s "\033[0m")))
         row-get              (fn [row k]
                                (when (contains? row k)
                                  ((column-coercions k identity) (get row k))))
         key->label           (if (map? ks) ks #(subs (str (keyword %)) 1))
         header-keys          (if (map? ks) (keys ks) ks)
         ;; ensure all header-keys exist for every row and every value is a string
         rows                 (map (fn [row]
                                     (reduce (fn [acc k]
                                               (assoc acc k (str (row-get row k)))) {} header-keys)) rows)
         header-keys          (if show-empty-columns
                                header-keys
                                (let [non-empty-cols (remove
                                                      (fn [k] (every? str/blank? (map #(get % k) rows)))
                                                      header-keys)]
                                  (filter (set non-empty-cols) header-keys)))
         header-labels        (map key->label header-keys)
         column-widths        (reduce (fn [acc k]
                                        (let [val-widths (map count (cons (key->label k)
                                                                          (map #(get % k) rows)))]
                                          (assoc acc k (apply max val-widths)))) {} header-keys)
         row-fmt              (str/join "  " (map #(str "%-" (column-widths %) "s") header-keys))
         cells->formatted-row #(apply format row-fmt %)
         plain-header-row     (cells->formatted-row header-labels)
         required-width       (count plain-header-row)
         header-row           (wrap-bold plain-header-row)
         max-width-exceeded?  (and max-width
                                   (> required-width max-width))
         div-row              (wrap-bold
                               (cells->formatted-row
                                (map (fn [k]
                                       (apply str (take (column-widths k) (repeat \u2500)))) header-keys)))
         data-rows            (map #(cells->formatted-row (map % header-keys)) rows)]
     (if-not max-width-exceeded?
       (when (seq header-keys)
         (let [header (if skip-header (vector) (vector header-row div-row))]
           (println (apply str (interpose \newline (into header data-rows))))))
       (let [overflow         (- required-width max-width)
             max-column-width (max 0 (- (column-widths width-reduce-column) overflow))
             width-reduce-fn  (or width-reduce-fn #(truncate %1 {:truncate-to %2}))
             coercion-fn      #(width-reduce-fn % max-column-width)]
         (recur ks rows (assoc opts
                               :max-width nil
                               :column-coercions {width-reduce-column coercion-fn})))))))

(defn edn? [cli-opts]
  (:edn cli-opts))

(defn print-scripts [printable-scripts cli-opts]
  (let [no-color?         (no-color? cli-opts)
        plain-mode?       (plain-mode? cli-opts)
        skip-header?      plain-mode?
        column-atts       '(:bin :version :location)
        column-coercions  {:version #(if (or plain-mode? (not= 40 (count %)))
                                       %
                                       (subs % 0 7))}
        max-width         (when-not plain-mode?
                            (:cols (terminal-dimensions)))
        location-truncate #(-> %1
                               (str/replace #"^(file|https?):\/\/" "")
                               (truncate {:truncate-to       %2
                                          :omission          "…"
                                          :omission-position :center}))]
    (print-table column-atts (sort-by :bin printable-scripts) {:skip-header         skip-header?
                                                               :max-width           max-width
                                                               :width-reduce-column :location
                                                               :width-reduce-fn     location-truncate
                                                               :column-coercions    column-coercions
                                                               :no-color            no-color?})))

(def help-commands
  (->> [{:command "bbin install" :doc "Install a script"}
        (when (upgrade-enabled?)
          {:command "bbin upgrade" :doc "Upgrade a script"})
        {:command "bbin uninstall" :doc "Remove a script"}
        {:command "bbin ls" :doc "List installed scripts"}
        {:command "bbin bin" :doc "Display bbin bin folder"}
        {:command "bbin version" :doc "Display bbin version"}
        {:command "bbin help" :doc "Display bbin help"}
        {:command "bbin migrate" :doc "Migrate from bbin v0.1.x"}]
       (remove nil?)))

(defn print-help [& _]
  (let [max-width (apply max (map #(count (:command %)) help-commands))
        lines (->> help-commands
                   (map (fn [{:keys [command doc]}]
                          (format (str "  %-" (inc max-width) "s %s") command doc))))]
    (println (str "Version: " meta/version))
    (println)
    (println (str "Usage: bbin <command>\n\n" (str/join "\n" lines)))))

(def windows?
  (some-> (System/getProperty "os.name")
          (str/lower-case)
          (str/index-of "win")))

(defn print-version [& {:as opts}]
  (if (:help opts)
    (print-help)
    (println "bbin" meta/version)))

(defn- parse-version [version]
  (mapv #(Integer/parseInt %)
        (-> version
            (str/replace "-SNAPSHOT" "")
            (str/split #"\."))))

(defn- satisfies-min-version? [current-version min-version]
  (let [[major-current minor-current patch-current] (parse-version current-version)
        [major-min minor-min patch-min] (parse-version min-version)]
    (or (> major-current major-min)
        (and (= major-current major-min)
             (or (> minor-current minor-min)
                 (and (= minor-current minor-min)
                      (>= patch-current patch-min)))))))

(defn check-min-bb-version []
  (let [current-bb-version (System/getProperty "babashka.version")]
    (when (and meta/min-bb-version (not= meta/min-bb-version :version-not-set))
      (when-not (satisfies-min-version? current-bb-version meta/min-bb-version)
        (binding [*out* *err*]
          (println (str "WARNING: this project requires babashka "
                        meta/min-bb-version " or newer, but you have: "
                        current-bb-version)))))))

(defn snake-case [s]
  (str/replace s "_" "-"))

(defmacro whenbb [& forms]
  (when (System/getProperty "babashka.version")
    `(do ~@forms)))

(ns babashka.bbin.scripts.common
  (:require [babashka.bbin.deps :as bbin-deps]
            [babashka.bbin.dirs :as dirs]
            [babashka.bbin.specs]
            [babashka.bbin.util :as util :refer [sh whenbb]]
            [babashka.fs :as fs]
            [clojure.edn :as edn]
            [clojure.main :as main]
            [clojure.spec.alpha :as s]
            [clojure.string :as str]
            [selmer.parser :as selmer]
            [selmer.util :as selmer-util])
  (:import (java.util.jar JarFile)))

(def bb-shebang-str "#!/usr/bin/env bb")

(defn- bb-shebang? [s]
  (str/starts-with? s bb-shebang-str))

(defn insert-script-header [script-contents header]
  (let [prev-lines (str/split-lines script-contents)
        [prefix [shebang & code]] (split-with #(not (bb-shebang? %)) prev-lines)
        header (concat [""
                        "; :bbin/start"
                        ";"]
                       (map #(str "; " %)
                            (str/split-lines
                             (with-out-str
                               (util/pprint header))))
                       [";"
                        "; :bbin/end"
                        ""])
        next-lines (if shebang
                     (concat prefix [shebang] header code)
                     (concat [bb-shebang-str] header prefix))]
    (str/join "\n" next-lines)))

(defn file-path->script-name [file-path]
  (-> file-path
      fs/file-name
      fs/strip-ext
      util/snake-case))

(defn http-url->script-name [http-url]
  (util/snake-case
   (first
    (str/split (last (str/split http-url #"/"))
               #"\."))))

(def windows-wrapper-extension ".bat")

(defn install-script
  "Spits `contents` to `path` (adding an extension on Windows), or
  pprints them if `dry-run?` is truthy.
  Side-effecting."
  [script-name header path contents & {:keys [dry-run] :as cli-opts}]
  (let [path-str (str path)]
    (if dry-run
      (util/pprint {:script-file     path-str
                    :script-contents contents}
                   dry-run)
      (do
        (spit path-str contents)
        (when-not util/windows? (sh ["chmod" "+x" path-str]))
        (when util/windows?
          (spit (str path-str windows-wrapper-extension)
                (str "@bb -f %~dp0" (fs/file-name path-str) " -- %*")))
        (if (util/edn? cli-opts)
          (util/pprint header)
          (do
            (println)
            (util/print-scripts (util/printable-scripts {script-name header})
                                cli-opts)
            (println)
            (println (util/bold "Install complete." cli-opts))
            (println)))
        nil))))

(defn- generate-deps-lib-name [git-url]
  (let [s (str "script-"
               (.hashCode git-url)
               "-"
               (-> git-url
                   (str/replace #"[^a-zA-Z0-9-]" "-")
                   (str/replace #"--+" "-")))]
    (symbol "org.babashka.bbin" s)))

(defn local-lib-path [script-deps]
  (let [lib (key (first script-deps))
        coords (val (first script-deps))]
    (if (#{::no-lib} lib)
      (:local/root coords)
      (fs/expand-home (str/join fs/file-separator ["~" ".gitlibs" "libs" (namespace lib) (name lib) (:git/sha coords)])))))

(defn- load-bin-config [script-root]
  (let [bb-file (fs/file script-root "bb.edn")
        bb-edn (when (fs/exists? bb-file)
                 (some-> bb-file slurp edn/read-string))
        bin-config (:bbin/bin bb-edn)]
    (when bin-config
      (if (s/valid? :bbin/bin bin-config)
        bin-config
        (throw (ex-info (s/explain-str :bbin/bin bin-config)
                        {:bbin/bin bin-config}))))))

(defn default-script-config [cli-opts]
  (let [[ns name] (str/split (:script/lib cli-opts) #"/")
        top (last (str/split ns #"\."))]
    {:main-opts ["-m" (str top "." name)]
     :ns-default (str top "." name)}))

(def comment-char ";")

(def ^:private local-dir-tool-template-str
  (str/trim "
#!/usr/bin/env bb

; :bbin/start
;
{{script/meta}}
;
; :bbin/end

(require '[babashka.process :as process]
         '[babashka.fs :as fs]
         '[clojure.string :as str])

(def script-root {{script/root|pr-str}})
(def script-ns-default '{{script/ns-default}})
(def script-name (fs/file-name *file*))

(def tmp-edn
  (doto (fs/file (fs/temp-dir) (str (gensym \"bbin\")))
    (spit (str \"{:deps {local/deps {:local/root \" (pr-str script-root) \"}}}\"))
    (fs/delete-on-exit)))

(def base-command
  [\"bb\" \"--deps-root\" script-root \"--config\" (str tmp-edn)])

(defn help-eval-str []
  (str \"(require '\" script-ns-default \")
        (def fns (filter #(fn? (deref (val %))) (ns-publics '\" script-ns-default \")))
        (def max-width (->> (keys fns) (map (comp count str)) (apply max)))
        (defn pad-right [x] (format (str \\\"%-\\\" max-width \\\"s\\\") x))
        (println (str \\\"Usage: \" script-name \" <command>\\\"))
        (newline)
        (doseq [[k v] fns]
          (println
            (str \\\"  \" script-name \" \\\" (pad-right k) \\\"  \\\"
               (when (:doc (meta v))
                 (first (str/split-lines (:doc (meta v))))))))\"))

(def first-arg (first *command-line-args*))
(def rest-args (rest *command-line-args*))

(if first-arg
  (process/exec
    (vec (concat base-command
                 [\"-x\" (str script-ns-default \"/\" first-arg)]
                 rest-args)))
  (process/exec (into base-command [\"-e\" (help-eval-str)])))
"))

(def ^:private deps-tool-template-str
  (str/trim "
#!/usr/bin/env bb

; :bbin/start
;
{{script/meta}}
;
; :bbin/end

(require '[babashka.process :as process]
         '[babashka.fs :as fs]
         '[clojure.string :as str])

(def script-root {{script/root|pr-str}})
(def script-lib '{{script/lib}})
(def script-coords {{script/coords|str}})
(def script-ns-default '{{script/ns-default}})
(def script-name (fs/file-name *file*))

(def tmp-edn
  (doto (fs/file (fs/temp-dir) (str (gensym \"bbin\")))
    (spit (str \"{:deps {\" script-lib script-coords \"}}\"))
    (fs/delete-on-exit)))

(def base-command
  [\"bb\" \"--deps-root\" script-root \"--config\" (str tmp-edn)])

(defn help-eval-str []
  (str \"(require '\" script-ns-default \")
        (def fns (filter #(fn? (deref (val %))) (ns-publics '\" script-ns-default \")))
        (def max-width (->> (keys fns) (map (comp count str)) (apply max)))
        (defn pad-right [x] (format (str \\\"%-\\\" max-width \\\"s\\\") x))
        (println (str \\\"Usage: \" script-name \" <command>\\\"))
        (newline)
        (doseq [[k v] fns]
          (println
            (str \\\"  \" script-name \" \\\" (pad-right k) \\\"  \\\"
               (when (:doc (meta v))
                 (first (str/split-lines (:doc (meta v))))))))\"))

(def first-arg (first *command-line-args*))
(def rest-args (rest *command-line-args*))

(if first-arg
  (process/exec
    (vec (concat base-command
                 [\"-x\" (str script-ns-default \"/\" first-arg)]
                 rest-args)))
  (process/exec (into base-command [\"-e\" (help-eval-str)])))
"))

(def ^:private local-dir-template-str
  (str/trim "
#!/usr/bin/env bb

; :bbin/start
;
{{script/meta}}
;
; :bbin/end

(require '[babashka.process :as process]
         '[babashka.fs :as fs]
         '[clojure.string :as str])

(def script-root {{script/root|pr-str}})
(def script-main-opts-first {{script/main-opts.0|pr-str}})
(def script-main-opts-second {{script/main-opts.1|pr-str}})

(def tmp-edn
  (doto (fs/file (fs/temp-dir) (str (gensym \"bbin\")))
    (spit (str \"{:deps {local/deps {:local/root \" (pr-str script-root) \"}}}\"))
    (fs/delete-on-exit)))

(def base-command
  [\"bb\" \"--deps-root\" script-root \"--config\" (str tmp-edn)
        script-main-opts-first script-main-opts-second
        \"--\"])

(process/exec (into base-command *command-line-args*))
"))

(def ^:private git-or-local-template-str
  (str/trim "
#!/usr/bin/env bb

; :bbin/start
;
{{script/meta}}
;
; :bbin/end

(require '[babashka.process :as process]
         '[babashka.fs :as fs]
         '[clojure.string :as str])

(def script-root {{script/root|pr-str}})
(def script-lib '{{script/lib}})
(def script-coords {{script/coords|str}})
(def script-main-opts-first {{script/main-opts.0|pr-str}})
(def script-main-opts-second {{script/main-opts.1|pr-str}})

(def tmp-edn
  (doto (fs/file (fs/temp-dir) (str (gensym \"bbin\")))
    (spit (str \"{:deps {\" script-lib script-coords \"}}\"))
    (fs/delete-on-exit)))

(def base-command
  [\"bb\" \"--deps-root\" script-root \"--config\" (str tmp-edn)
        script-main-opts-first script-main-opts-second
        \"--\"])

(process/exec (into base-command *command-line-args*))
"))

(defn install-deps-git-or-local [cli-opts {:keys [procurer] :as _summary}]
  (let [script-deps (cond
                      (and (#{:local} procurer) (not (:local/root cli-opts)))
                      {::no-lib {:local/root (str (fs/canonicalize (:script/lib cli-opts) {:nofollow-links true}))}}

                      (bbin-deps/git-repo-url? (:script/lib cli-opts))
                      (bbin-deps/infer
                       (cond-> (assoc cli-opts :lib (str (generate-deps-lib-name (:script/lib cli-opts)))
                                      :git/url (:script/lib cli-opts))
                         (not (some cli-opts [:latest-tag :latest-sha :git/sha :git/tag]))
                         (assoc :latest-sha true)))

                      :else
                      (bbin-deps/infer (assoc cli-opts :lib (:script/lib cli-opts))))
        lib (key (first script-deps))
        coords (val (first script-deps))
        header (merge {:coords coords} (when-not (#{::no-lib} lib) {:lib lib}))
        header' (if (#{::no-lib} lib)
                  {:coords {:bbin/url (str "file://" (get-in header [:coords :local/root]))}}
                  header)
        _ (whenbb (when-not (#{::no-lib} lib)
                    ((requiring-resolve 'babashka.deps/add-deps)
                     {:deps script-deps})))
        script-root (fs/canonicalize (or (get-in header [:coords :local/root])
                                         (local-lib-path script-deps))
                                     {:nofollow-links true})
        bin-config (load-bin-config script-root)
        script-name (or (:as cli-opts)
                        (some-> bin-config first key str)
                        (and (not (#{::no-lib} lib))
                             (second (str/split (:script/lib cli-opts) #"/"))))
        _ (when (str/blank? script-name)
            (throw (ex-info "Script name not found. Use --as or :bbin/bin to provide a script name."
                            header)))
        script-config (merge (when-not (#{::no-lib} lib)
                               (default-script-config cli-opts))
                             (some-> bin-config first val)
                             (when (:ns-default cli-opts)
                               {:ns-default (edn/read-string (:ns-default cli-opts))}))
        script-edn-out (with-out-str
                         (binding [*print-namespace-maps* false]
                           (util/pprint header')))
        tool-mode (or (:tool cli-opts)
                      (and (some-> bin-config first val :ns-default)
                           (not (some-> bin-config first val :main-opts))))
        main-opts (or (some-> (:main-opts cli-opts) edn/read-string)
                      (:main-opts script-config))
        _ (when (and (not tool-mode) (not (seq main-opts)))
            (throw (ex-info "Main opts not found. Use --main-opts or :bbin/bin to provide main opts."
                            {})))
        template-opts {:script/meta (->> script-edn-out
                                         str/split-lines
                                         (map #(str comment-char " " %))
                                         (str/join "\n"))
                       :script/root script-root
                       :script/lib (pr-str (key (first script-deps)))
                       :script/coords (binding [*print-namespace-maps* false] (pr-str (val (first script-deps))))}
        template-opts' (if tool-mode
                         (assoc template-opts :script/ns-default (:ns-default script-config))
                         (assoc template-opts :script/main-opts
                                [(first main-opts)
                                 (if (= "-f" (first main-opts))
                                   (fs/canonicalize (fs/file script-root (second main-opts))
                                                    {:nofollow-links true})
                                   (second main-opts))]))
        template-str (if tool-mode
                       (if (#{::no-lib} lib)
                         local-dir-tool-template-str
                         deps-tool-template-str)
                       (if (#{::no-lib} lib)
                         local-dir-template-str
                         git-or-local-template-str))
        template-out (selmer-util/without-escaping
                      (selmer/render template-str template-opts'))
        script-file (fs/canonicalize (fs/file (dirs/bin-dir cli-opts) script-name) {:nofollow-links true})]
    (install-script script-name header' script-file template-out cli-opts)))

(defn jar->main-ns [jar-path]
  (with-open [jar-file (JarFile. (fs/file jar-path))]
    (let [main-attributes (some-> jar-file .getManifest .getMainAttributes)
          ;; TODO After July 17th 2023: Remove workaround below and start using (.getValue "Main-Class") instead
          ;;      (see https://github.com/babashka/bbin/pull/47#discussion_r1071348344)
          main-class (some (fn [[k v]] (when (str/includes? k "Main-Class") v))
                           main-attributes)]
      (if main-class
        (main/demunge main-class)
        (throw (ex-info "jar has no Main-Class" {:jar-path jar-path}))))))

(defn delete-files [cli-opts]
  (let [script-name (:script/lib cli-opts)
        script-file (fs/canonicalize (fs/file (dirs/bin-dir cli-opts) script-name) {:nofollow-links true})]
    (when (fs/delete-if-exists script-file)
      (when util/windows? (fs/delete-if-exists (fs/file (str script-file windows-wrapper-extension))))
      (fs/delete-if-exists (fs/file (dirs/jars-dir cli-opts) (str script-name ".jar")))
      (println "Removing" (str script-file)))))

(ns babashka.bbin.scripts.local-dir
  (:require [babashka.bbin.protocols :as p]
            [babashka.bbin.scripts.common :as common]))

(defrecord LocalDir [cli-opts summary]
  p/Script
  (install [_]
    (common/install-deps-git-or-local cli-opts summary))

  (upgrade [_]
    (throw (ex-info "Not implemented" {})))

  (uninstall [_]
    (common/delete-files cli-opts)))

(ns babashka.bbin.scripts.http-jar
  (:require [babashka.bbin.dirs :as dirs]
            [babashka.bbin.protocols :as p]
            [babashka.bbin.scripts.common :as common]
            [babashka.bbin.util :as util]
            [babashka.fs :as fs]
            [babashka.http-client :as http]
            [clojure.java.io :as io]
            [clojure.string :as str]
            [selmer.parser :as selmer]
            [selmer.util :as selmer-util]))

(def ^:private local-jar-template-str
  (str/trim "
#!/usr/bin/env bb

; :bbin/start
;
{{script/meta}}
;
; :bbin/end

(require '[babashka.classpath :refer [add-classpath]])

(def script-jar {{script/jar|pr-str}})

(add-classpath script-jar)

(require '[{{script/main-ns}}])
(apply {{script/main-ns}}/-main *command-line-args*)
"))

(defrecord HttpJar [cli-opts coords]
  p/Script
  (install [_]
    (fs/create-dirs (dirs/jars-dir cli-opts))
    (let [http-url (:script/lib cli-opts)
          script-deps {:bbin/url http-url}
          header {:coords script-deps}
          script-name (or (:as cli-opts) (common/http-url->script-name http-url))
          tmp-jar-path (doto (fs/file (fs/temp-dir) (str script-name ".jar"))
                         (fs/delete-on-exit))
          _ (io/copy (:body (http/get http-url {:as :bytes})) tmp-jar-path)
          main-ns (common/jar->main-ns tmp-jar-path)
          cached-jar-path (fs/file (dirs/jars-dir cli-opts) (str script-name ".jar"))
          _ (fs/move tmp-jar-path cached-jar-path {:replace-existing true})
          script-edn-out (with-out-str
                           (binding [*print-namespace-maps* false]
                             (util/pprint header)))
          template-opts {:script/meta (->> script-edn-out
                                           str/split-lines
                                           (map #(str common/comment-char " " %))
                                           (str/join "\n"))
                         :script/main-ns main-ns
                         :script/jar cached-jar-path}
          script-contents (selmer-util/without-escaping
                           (selmer/render local-jar-template-str template-opts))
          script-file (fs/canonicalize (fs/file (dirs/bin-dir cli-opts) script-name)
                                       {:nofollow-links true})]
      (common/install-script script-name header script-file script-contents cli-opts)))

  (upgrade [_]
    (let [cli-opts' (merge (select-keys cli-opts [:edn])
                           {:script/lib (:bbin/url coords)})]
      (p/install (map->HttpJar {:cli-opts cli-opts'
                                :coords coords}))))

  (uninstall [_]
    (common/delete-files cli-opts)))

(ns babashka.bbin.scripts.git-dir
  (:require [babashka.bbin.protocols :as p]
            [babashka.bbin.scripts.common :as common]))

(defrecord GitDir [cli-opts summary coords]
  p/Script
  (install [_]
    (common/install-deps-git-or-local cli-opts summary))

  (upgrade [_]
    (throw (ex-info "Not implemented" {:cli-opts cli-opts
                                       :summary summary
                                       :coords coords})))

  (uninstall [_]
    (common/delete-files cli-opts)))

(ns babashka.bbin.scripts.http-file
  (:require [babashka.bbin.dirs :as dirs]
            [babashka.bbin.protocols :as p]
            [babashka.bbin.scripts.common :as common]
            [babashka.fs :as fs]))

(defrecord HttpFile [cli-opts coords]
  p/Script
  (install [_]
    (let [http-url (:script/lib cli-opts)
          script-deps {:bbin/url http-url}
          header {:coords script-deps}
          script-name (or (:as cli-opts) (common/http-url->script-name http-url))
          script-contents (-> (slurp (:bbin/url script-deps))
                              (common/insert-script-header header))
          script-file (fs/canonicalize (fs/file (dirs/bin-dir cli-opts) script-name)
                                       {:nofollow-links true})]
      (common/install-script script-name header script-file script-contents cli-opts)))

  (upgrade [_]
    (let [cli-opts' (merge (select-keys cli-opts [:edn])
                           {:script/lib (:bbin/url coords)})]
      (p/install (map->HttpFile {:cli-opts cli-opts'
                                 :coords coords}))))

  (uninstall [_]
    (common/delete-files cli-opts)))

(ns babashka.bbin.scripts.maven-jar
  (:require [babashka.bbin.dirs :as dirs]
            [babashka.bbin.protocols :as p]
            [babashka.bbin.scripts.common :as common]
            [babashka.bbin.util :as util :refer [whenbb]]
            [babashka.fs :as fs]
            [babashka.http-client :as http]
            [babashka.json :as json]
            [clojure.edn :as edn]
            [clojure.string :as str]
            [selmer.parser :as selmer]
            [selmer.util :as selmer-util]))

(def ^:private maven-template-str
  (str/trim "
#!/usr/bin/env bb

; :bbin/start
;
{{script/meta}}
;
; :bbin/end

(require '[babashka.process :as process]
         '[babashka.fs :as fs]
         '[clojure.string :as str])

(def script-lib '{{script/lib}})
(def script-coords {{script/coords|str}})
(def script-main-opts-first {{script/main-opts.0|pr-str}})
(def script-main-opts-second {{script/main-opts.1|pr-str}})

(def tmp-edn
  (doto (fs/file (fs/temp-dir) (str (gensym \"bbin\")))
    (spit (str \"{:deps {\" script-lib script-coords \"}}\"))
    (fs/delete-on-exit)))

(def base-command
  [\"bb\" \"--config\" (str tmp-edn)
        script-main-opts-first script-main-opts-second
        \"--\"])

(process/exec (into base-command *command-line-args*))
"))

(defn- first-stable-version [versions]
  (let [vparse (requiring-resolve 'version-clj.core/parse)]
    (some (fn [version]
            (let [{:keys [qualifiers]} (vparse version)]
              (when-not (some #{"rc" "alpha" "beta" "snapshot" "milestone"} qualifiers)
                version)))
          versions)))

(defn- search-mvn [qlib limit]
  (let [url (format "https://search.maven.org/solrsearch/select?q=g:%s+AND+a:%s&rows=%s&core=gav&wt=json"
                    (namespace qlib)
                    (name qlib)
                    (str limit))]
    (json/read-str (:body (http/get url)))))

(defn- mvn-versions [qlib {:keys [limit] :or {limit 10}}]
  (let [payload (search-mvn qlib limit)]
    (->> payload
         :docs
         (map :v))))

(defn- latest-stable-mvn-version [qlib]
  (first-stable-version (mvn-versions qlib {:limit 100})))

(defn- get-clojars-artifact [qlib]
  (let [url (format "https://clojars.org/api/artifacts/%s"
                    qlib)]
    (json/read-str (:body (http/get url)))))

(defn- clojars-versions [qlib {:keys [limit] :or {limit 10}}]
  (let [body (get-clojars-artifact qlib)]
    (->> body
         :recent_versions
         (map :version)
         (take limit))))

(defn- latest-stable-clojars-version
  [qlib]
  (first-stable-version (clojars-versions qlib {:limit 100})))

(defrecord MavenJar [cli-opts lib]
  p/Script
  (install [_]
    (let [script-deps {(edn/read-string (:script/lib cli-opts))
                       (select-keys cli-opts [:mvn/version])}
          header {:lib (key (first script-deps))
                  :coords (val (first script-deps))}
          _ (whenbb ((requiring-resolve 'babashka.deps/add-deps)
                     {:deps script-deps}) )
          script-root (fs/canonicalize (or (:local/root cli-opts) (common/local-lib-path script-deps)) {:nofollow-links true})
          script-name (or (:as cli-opts) (second (str/split (:script/lib cli-opts) #"/")))
          script-config (common/default-script-config cli-opts)
          script-edn-out (with-out-str
                           (binding [*print-namespace-maps* false]
                             (util/pprint header)))
          main-opts (or (some-> (:main-opts cli-opts) edn/read-string)
                        (:main-opts script-config))
          template-opts {:script/meta (->> script-edn-out
                                           str/split-lines
                                           (map #(str common/comment-char " " %))
                                           (str/join "\n"))
                         :script/root script-root
                         :script/lib (pr-str (key (first script-deps)))
                         :script/coords (binding [*print-namespace-maps* false] (pr-str (val (first script-deps))))
                         :script/main-opts [(first main-opts)
                                            (if (= "-f" (first main-opts))
                                              (fs/canonicalize (fs/file script-root (second main-opts))
                                                               {:nofollow-links true})
                                              (second main-opts))]}
          template-out (selmer-util/without-escaping
                        (selmer/render maven-template-str template-opts))
          script-file (fs/canonicalize (fs/file (dirs/bin-dir cli-opts) script-name) {:nofollow-links true})]
      (common/install-script script-name header script-file template-out cli-opts)))

  (upgrade [_]
    (let [latest-version (or (latest-stable-clojars-version lib)
                             (latest-stable-mvn-version lib))
          cli-opts' (merge (select-keys cli-opts [:edn])
                           {:script/lib (str lib)
                            :mvn/version latest-version})]
      (p/install (map->MavenJar {:cli-opts cli-opts'
                                 :lib lib}))))

  (uninstall [_]
    (common/delete-files cli-opts)))

(ns babashka.bbin.scripts.local-file
  (:require [babashka.bbin.dirs :as dirs]
            [babashka.bbin.protocols :as p]
            [babashka.bbin.scripts.common :as common]
            [babashka.fs :as fs]
            [clojure.string :as str]))

(defrecord LocalFile [cli-opts coords]
  p/Script
  (install [_]
    (let [file-path (str (fs/canonicalize (:script/lib cli-opts) {:nofollow-links true}))
          script-deps {:bbin/url (str "file://" file-path)}
          header {:coords script-deps}
          script-name (or (:as cli-opts) (common/file-path->script-name file-path))
          script-contents (-> (slurp file-path)
                              (common/insert-script-header header))
          script-file (fs/canonicalize (fs/file (dirs/bin-dir cli-opts) script-name)
                                       {:nofollow-links true})]
      (common/install-script script-name header script-file script-contents cli-opts)))

  (upgrade [_]
    (let [cli-opts' (merge (select-keys cli-opts [:edn])
                           {:script/lib (str/replace (:bbin/url coords) #"^file://" "")})]
      (p/install (map->LocalFile {:cli-opts cli-opts'
                                  :coords coords}))))

  (uninstall [_]
    (common/delete-files cli-opts)))

(ns babashka.bbin.scripts.local-jar
  (:require [babashka.bbin.dirs :as dirs]
            [babashka.bbin.protocols :as p]
            [babashka.bbin.scripts.common :as common]
            [babashka.bbin.util :as util]
            [babashka.fs :as fs]
            [clojure.string :as str]
            [selmer.parser :as selmer]
            [selmer.util :as selmer-util]))

(def ^:private local-jar-template-str
  (str/trim "
#!/usr/bin/env bb

; :bbin/start
;
{{script/meta}}
;
; :bbin/end

(require '[babashka.classpath :refer [add-classpath]])

(def script-jar {{script/jar|pr-str}})

(add-classpath script-jar)

(require '[{{script/main-ns}}])
(apply {{script/main-ns}}/-main *command-line-args*)
"))

(defrecord LocalJar [cli-opts coords]
  p/Script
  (install [_]
    (fs/create-dirs (dirs/jars-dir cli-opts))
    (let [file-path (str (fs/canonicalize (:script/lib cli-opts) {:nofollow-links true}))
          main-ns (common/jar->main-ns file-path)
          script-deps {:bbin/url (str "file://" file-path)}
          header {:coords script-deps}
          script-name (or (:as cli-opts) (common/file-path->script-name file-path))
          cached-jar-path (fs/file (dirs/jars-dir cli-opts) (str script-name ".jar"))
          script-edn-out (with-out-str
                           (binding [*print-namespace-maps* false]
                             (util/pprint header)))
          template-opts {:script/meta (->> script-edn-out
                                           str/split-lines
                                           (map #(str common/comment-char " " %))
                                           (str/join "\n"))
                         :script/main-ns main-ns
                         :script/jar cached-jar-path}
          script-contents (selmer-util/without-escaping
                           (selmer/render local-jar-template-str template-opts))
          script-file (fs/canonicalize (fs/file (dirs/bin-dir cli-opts) script-name)
                                       {:nofollow-links true})]
      (fs/copy file-path cached-jar-path {:replace-existing true})
      (common/install-script script-name header script-file script-contents cli-opts)))

  (upgrade [_]
    (let [cli-opts' (merge (select-keys cli-opts [:edn])
                           {:script/lib (str/replace (:bbin/url coords) #"^file://" "")})]
      (p/install (map->LocalJar {:cli-opts cli-opts'
                                 :coords coords}))))

  (uninstall [_]
    (common/delete-files cli-opts)))

(ns babashka.bbin.scripts
  (:require
   [babashka.bbin.deps :as bbin-deps]
   [babashka.bbin.dirs :as dirs]
   [babashka.bbin.protocols :as p]
   [babashka.bbin.scripts.common :as common]
   [babashka.bbin.scripts.git-dir :refer [map->GitDir]]
   [babashka.bbin.scripts.http-file :refer [map->HttpFile]]
   [babashka.bbin.scripts.http-jar :refer [map->HttpJar]]
   [babashka.bbin.scripts.local-dir :refer [map->LocalDir]]
   [babashka.bbin.scripts.local-file :refer [map->LocalFile]]
   [babashka.bbin.scripts.local-jar :refer [map->LocalJar]]
   [babashka.bbin.scripts.maven-jar :refer [map->MavenJar]]
   [babashka.bbin.util :as util]
   [babashka.fs :as fs]
   [clojure.edn :as edn]
   [clojure.java.io :as io]
   [clojure.string :as str]
   [selmer.filters :as filters]))

;; selmer filter for clojure escaping for e.g. files
(filters/add-filter! :pr-str (comp pr-str str))

(defn parse-script [s]
  (let [lines (str/split-lines s)
        prefix (if (str/ends-with? (first lines) "bb") ";" "#")]
    (->> lines
         (drop-while #(not (re-seq (re-pattern (str "^" prefix " *:bbin/start")) %)))
         next
         (take-while #(not (re-seq (re-pattern (str "^" prefix " *:bbin/end")) %)))
         (map #(str/replace % (re-pattern (str "^" prefix " *")) ""))
         (str/join "\n")
         edn/read-string)))

(defn- read-header [filename]
  (or (with-open [input-stream (io/input-stream filename)]
        (let [buffer (byte-array (* 1024 5))
              n (.read input-stream buffer)]
          (when (nat-int? n)
            (String. buffer 0 n))))
      ""))

(defn load-scripts [dir]
  (->> (file-seq dir)
       (filter #(.isFile %))
       (map (fn [x] [(symbol (str (fs/relativize dir x)))
                     (-> (read-header x) (parse-script ))]))
       (filter second)
       (into {})))

(defn ls [cli-opts]
  (let [scripts (load-scripts (dirs/bin-dir cli-opts))]
    (if (:edn cli-opts)
      (util/pprint scripts cli-opts)
      (do
        (println)
        (util/print-scripts (util/printable-scripts scripts) cli-opts)
        (println)))))

(defn bin [cli-opts]
  (println (str (dirs/bin-dir cli-opts))))

(defn- throw-invalid-script [summary cli-opts]
  (let [{:keys [procurer artifact]} summary]
    (throw (ex-info "Invalid script coordinates.\nIf you're trying to install from the filesystem, make sure the path actually exists."
                    {:script/lib (:script/lib cli-opts)
                     :procurer procurer
                     :artifact artifact}))))

(defn- new-script [cli-opts]
  (let [summary (bbin-deps/summary cli-opts)
        {:keys [procurer artifact]} summary]
    (case [procurer artifact]
      [:git :dir] (map->GitDir {:cli-opts cli-opts :summary summary})
      [:http :file] (map->HttpFile {:cli-opts cli-opts})
      [:http :jar] (map->HttpJar {:cli-opts cli-opts})
      [:local :dir] (map->LocalDir {:cli-opts cli-opts :summary summary})
      [:local :file] (map->LocalFile {:cli-opts cli-opts})
      [:local :jar] (map->LocalJar {:cli-opts cli-opts})
      [:maven :jar] (map->MavenJar {:cli-opts cli-opts})
      (throw-invalid-script summary cli-opts))))

(defn install [cli-opts]
  (if-not (:script/lib cli-opts)
    (util/print-help)
    (do
      (dirs/ensure-bbin-dirs cli-opts)
      (when-not (util/edn? cli-opts)
        (println)
        (println (util/bold "Starting install..." cli-opts)))
      (let [cli-opts' (util/canonicalized-cli-opts cli-opts)
            script (new-script cli-opts')]
        (p/install script)))))

(defn- default-script [cli-opts]
  (reify
    p/Script
    (install [_])
    (upgrade [_]
      (throw (ex-info "Not implemented" {})))
    (uninstall [_]
      (common/delete-files cli-opts))))

(defn- load-script [cli-opts]
  (let [script-name (:script/lib cli-opts)
        script-file (fs/file (fs/canonicalize (fs/file (dirs/bin-dir cli-opts) script-name) {:nofollow-links true}))
        parsed (parse-script (read-header script-file))]
    (cond
      (-> parsed :coords :bbin/url)
      (let [summary (bbin-deps/summary {:script/lib (-> parsed :coords :bbin/url)})
            {:keys [procurer artifact]} summary]
        (case [procurer artifact]
          [:git :dir] (map->GitDir {:cli-opts cli-opts :summary summary :coords (:coords parsed)})
          [:http :file] (map->HttpFile {:cli-opts cli-opts :coords (:coords parsed)})
          [:http :jar] (map->HttpJar {:cli-opts cli-opts :coords (:coords parsed)})
          [:local :dir] (map->LocalDir {:cli-opts cli-opts :summary summary})
          [:local :file] (map->LocalFile {:cli-opts cli-opts :coords (:coords parsed)})
          [:local :jar] (map->LocalJar {:cli-opts cli-opts :coords (:coords parsed)})
          (throw-invalid-script summary cli-opts)))

      (-> parsed :coords :mvn/version)
      (map->MavenJar {:cli-opts cli-opts :lib (:lib parsed)})

      (-> parsed :coords :git/tag)
      (let [summary (bbin-deps/summary {:script/lib (:lib parsed)
                                        :git/tag (-> parsed :coords :git/tag)})]
        (map->GitDir {:cli-opts cli-opts :summary summary :coords (:coords parsed)}))

      (-> parsed :coords :git/sha)
      (let [summary (bbin-deps/summary {:script/lib (:lib parsed)
                                        :git/sha (-> parsed :coords :git/sha)})]
        (map->GitDir {:cli-opts cli-opts :summary summary :coords (:coords parsed)}))

      :else (default-script cli-opts))))

(defn upgrade [cli-opts]
  (if-not (:script/lib cli-opts)
    (util/print-help)
    (do
      (dirs/ensure-bbin-dirs cli-opts)
      (let [script (load-script cli-opts)]
        (p/upgrade script)))))

(defn uninstall [cli-opts]
  (if-not (:script/lib cli-opts)
    (util/print-help)
    (do
      (dirs/ensure-bbin-dirs cli-opts)
      (let [script-name (:script/lib cli-opts)
            script-file (fs/canonicalize (fs/file (dirs/bin-dir cli-opts) script-name) {:nofollow-links true})]
        (when (fs/delete-if-exists script-file)
          (when util/windows? (fs/delete-if-exists (fs/file (str script-file common/windows-wrapper-extension))))
          (fs/delete-if-exists (fs/file (dirs/jars-dir cli-opts) (str script-name ".jar")))
          (println "Removing" (str script-file)))))))

(ns babashka.bbin.migrate
  (:require [babashka.bbin.dirs :as dirs]
            [babashka.bbin.scripts :as scripts]
            [babashka.bbin.util :as util]
            [babashka.fs :as fs]
            [clojure.string :as str]))

(def templates
  {:found-scripts
   (fn [{:keys [cli-opts]}]
     (let [{:keys [force]} cli-opts]
       (println (util/bold "We found scripts in ~/.babashka/bbin/bin." cli-opts))
       (if force
         (println "The --force option was enabled. We'll continue the migration without prompting.")
         (do
           (println "We'll ask you to confirm each script individually and back up the original before replacement.")
           (println "Re-run this command with --force to migrate all scripts without confirming.")))))

   :printable-scripts
   (fn [{:keys [scripts cli-opts]}]
     (util/print-scripts (util/printable-scripts scripts) cli-opts))

   :prompt-move
   (fn [{:keys [cli-opts]}]
     (println (util/bold "Would you like to move your scripts to ~/.local/bin? (yes/no)" cli-opts))
     (print "> "))

   :migrating
   (fn [{:keys [cli-opts]}]
     (println (util/bold "Migrating..." cli-opts)))

   :up-to-date
   (fn [_]
     (println "Up-to-date."))

   :copying
   (fn [{:keys [src dest]}]
     (println "Copying" src "to" dest))

   :moving
   (fn [{:keys [src dest]}]
     (println "Moving" src "to" dest))

   :canceled
   (fn [{:keys [cli-opts]}]
     (println (util/bold "Migration canceled." cli-opts)))

   :done
   (fn [{:keys [cli-opts]}]
     (println (util/bold "Migration complete." cli-opts)))

   :confirm-replace
   (fn [{:keys [dest cli-opts]}]
     (println (util/bold (str dest " already exists. Do you want to replace it? (yes/no) ")
                         cli-opts))
     (print "> ")
     (flush))

   :skipping
   (fn [{:keys [src]}]
     (println "Skipping" src))})

(defn- printer [log-path cli-opts]
  (fn [k & {:as opts}]
    (let [cmd (if opts [k opts] [k])]
      (when log-path
        (spit log-path (prn-str cmd) :append true))
      (if (:edn cli-opts)
        (prn cmd)
        ((get templates k) (assoc opts :cli-opts cli-opts))))))

(defn log-path [s migration-id]
  (str s "." migration-id ".log"))

(defn src-backup-path [s migration-id]
  (str s ".src." migration-id ".backup"))

(defn dest-backup-path [s migration-id]
  (str s ".dest." migration-id ".backup"))

(defn- confirm-one-script [script-name {:keys [force] :as cli-opts} t]
  (let [bin-dest (str (fs/file (dirs/xdg-bin-dir cli-opts) (name script-name)))]
    (if (or force (not (fs/exists? bin-dest)))
      true
      (do
        (println)
        (t :confirm-replace {:dest bin-dest})
        (= "yes" (str/trim (read-line)))))))

(defn- confirm-all-scripts [scripts cli-opts t]
  (->> scripts
       (map (fn [[script-name _]]
              [script-name (confirm-one-script script-name cli-opts t)]))
       (remove (fn [[_ confirmed]] (nil? confirmed)))
       doall))

(defn- copy-script [script-name confirmed migration-id cli-opts t]
  (let [bin-src (str (fs/file (dirs/legacy-bin-dir) (name script-name)))
        bin-dest (str (fs/file (dirs/xdg-bin-dir cli-opts) (name script-name)))
        bin-dest-backup (str (fs/file (dest-backup-path (dirs/legacy-bin-dir) migration-id)
                                      (name script-name)))
        bat-src (str (fs/file (dirs/legacy-bin-dir) (str script-name ".bat")))
        bat-dest (str (fs/file (dirs/xdg-bin-dir cli-opts) (str script-name ".bat")))
        bat-dest-backup (str (fs/file (dest-backup-path (dirs/legacy-bin-dir) migration-id)
                                      (str script-name ".bat")))
        jar-src (str (fs/file (dirs/legacy-jars-dir) (str script-name ".jar")))
        jar-dest (str (fs/file (dirs/xdg-jars-dir cli-opts) (str script-name ".jar")))
        jar-dest-backup (str (fs/file (dest-backup-path (dirs/legacy-jars-dir) migration-id)
                                      (str script-name ".jar")))
        copy-bin (fn []
                   (when (fs/exists? bin-dest)
                     (fs/create-dirs (fs/parent bin-dest-backup))
                     (t :copying {:src bin-dest :dest bin-dest-backup})
                     (fs/copy bin-dest bin-dest-backup {:replace-existing true}))
                   (t :copying {:src bin-src :dest bin-dest})
                   (fs/copy bin-src bin-dest {:replace-existing true}))
        copy-bat (fn []
                   (when (fs/exists? bat-src)
                     (when (fs/exists? bat-dest)
                       (fs/create-dirs (fs/parent bat-dest-backup))
                       (t :copying {:src bat-dest :dest bat-dest-backup})
                       (fs/copy bat-dest bat-dest-backup {:replace-existing true}))
                     (t :copying {:src bat-src :dest bat-dest})
                     (fs/copy bat-src bat-dest {:replace-existing true})))
        copy-jar (fn []
                   (when (fs/exists? jar-src)
                     (when (fs/exists? jar-dest)
                       (fs/create-dirs (fs/parent jar-dest-backup))
                       (t :copying {:src jar-dest :dest jar-dest-backup})
                       (fs/copy jar-dest jar-dest-backup {:replace-existing true}))
                     (t :copying {:src jar-src :dest jar-dest})
                     (spit bin-dest (str/replace (slurp bin-dest) jar-src jar-dest))
                     (fs/copy jar-src jar-dest {:replace-existing true})))]
    (if-not confirmed
      (t :skipping {:src bin-src})
      (do
        (copy-bin)
        (copy-bat)
        (copy-jar)))))

(defn move-legacy-dirs [t migration-id]
  (let [bin-src (str (dirs/legacy-bin-dir))
        bin-dest (src-backup-path bin-src migration-id)
        jars-src (str (dirs/legacy-jars-dir))
        jars-dest (src-backup-path jars-src migration-id)]
    (t :moving {:src bin-src :dest bin-dest})
    (fs/move bin-src bin-dest)
    (when (fs/exists? jars-src)
      (t :moving {:src jars-src :dest jars-dest})
      (fs/move jars-src jars-dest))))

(defn migrate-auto [{:keys [force] :as cli-opts}]
  (let [migration-id (inst-ms (util/now))
        logp (when (dirs/using-legacy-paths?)
               (log-path (dirs/legacy-bin-dir) migration-id))
        t (printer logp cli-opts)]
    (if-not (dirs/using-legacy-paths?)
      (t :up-to-date)
      (let [scripts (scripts/load-scripts (dirs/legacy-bin-dir))]
        (when (seq scripts)
          (println)
          (t :printable-scripts {:scripts scripts})
          (println)
          (t :found-scripts)
          (when-not force
            (println)
            (t :prompt-move)))
        (flush)
        (if (or force (= "yes" (str/trim (read-line))))
          (do
            (dirs/ensure-xdg-dirs cli-opts)
            (if-not (seq scripts)
              (do
                (println)
                (t :migrating)
                (println)
                (move-legacy-dirs t migration-id)
                (println)
                (t :done)
                (println))
              (do
                (flush)
                (let [confirm-results (confirm-all-scripts scripts cli-opts t)]
                  (println)
                  (t :migrating)
                  (doseq [[script-name confirmed] confirm-results]
                    (copy-script script-name confirmed migration-id cli-opts t)))
                (move-legacy-dirs t migration-id)
                (println)
                (t :done)
                (println))))
          (do
            (println)
            (t :canceled)
            (println)))))))

(defn migrate-help [_]
  (println (str/triml "
In bbin 0.2.0, we now use the XDG Base Directory Specification by default.
This means the ~/.babashka/bbin/bin path is deprecated in favor of ~/.local/bin.

To migrate your scripts automatically, run `bbin migrate auto`. We won't make
any changes without asking first.

Otherwise, you can either a) migrate manually or b) override:

  a) Migrate manually:
    - Move files in ~/.babashka/bbin/bin to ~/.local/bin
    - Move files in ~/.babashka/bbin/jars to ~/.cache/babashka/bbin/jars
    - For each script that uses a JAR, edit the line containing
      `(def script-jar ...)` to use the new \"~/.cache/babashka/bbin/jars\" path.

  b) Override:
    - Set the BABASHKA_BBIN_BIN_DIR env variable to \"$HOME/.babashka/bbin\"
    - Set the BABASHKA_BBIN_JARS_DIR env variable to \"$HOME/.babashka/jars\"
")))

(defn migrate
  ([cli-opts] (migrate :root cli-opts))
  ([command cli-opts]
   (case command
     :root (migrate-help cli-opts)
     :auto (migrate-auto cli-opts))))

(ns babashka.bbin.cli
  (:require [babashka.bbin.dirs :as dirs]
            [babashka.bbin.migrate :as migrate]
            [babashka.bbin.scripts :as scripts]
            [babashka.bbin.util :as util]
            [babashka.cli :as cli]
            [clojure.string :as str]))

(declare print-commands)

(defn- run [command-fn parsed & {:keys [disable-legacy-paths-check]}]
  (let [cli-opts (:opts parsed)]
    (when-not disable-legacy-paths-check
      (dirs/check-legacy-paths))
    (if (and (:version cli-opts) (not (:help cli-opts)))
      (util/print-version)
      (command-fn cli-opts))))

(defn- add-global-aliases [commands]
  (map #(assoc-in % [:aliases :h] :help) commands))

(defn- base-commands
  [& {:as opts}]
  (->> [{:cmds ["commands"]
         :fn #(run print-commands %)}

        {:cmds ["help"]
         :fn #(run util/print-help %)}

        {:cmds ["install"]
         :fn #(run (:install-fn opts) %)
         :args->opts [:script/lib]
         :aliases {:T :tool}}

        {:cmds ["migrate" "auto"]
         :fn #(run (partial (:migrate-fn opts) :auto) %
                   :disable-legacy-paths-check true)}

        {:cmds ["migrate"]
         :fn #(run (:migrate-fn opts) %
                   :disable-legacy-paths-check true)}

        (when (util/upgrade-enabled?)
          {:cmds ["upgrade"]
           :fn #(run (:upgrade-fn opts) %)
           :args->opts [:script/lib]})

        {:cmds ["uninstall"]
         :fn #(run (:uninstall-fn opts) %)
         :args->opts [:script/lib]}

        {:cmds ["ls"]
         :fn #(run (:ls-fn opts) %)}

        {:cmds ["bin"]
         :fn #(run (:bin-fn opts) %)}

        {:cmds ["version"]
         :fn #(run util/print-version %)}

        {:cmds []
         :fn #(run util/print-help %)}]
       (remove nil?)))

(defn- full-commands [& {:as run-opts}]
  (add-global-aliases (base-commands run-opts)))

(defn- print-commands [_]
  (println (str/join " " (keep #(first (:cmds %)) (full-commands)))))

(def default-run-opts
  {:install-fn scripts/install
   :upgrade-fn scripts/upgrade
   :uninstall-fn scripts/uninstall
   :ls-fn scripts/ls
   :bin-fn scripts/bin
   :migrate-fn migrate/migrate})

(defn bbin [main-args & {:as run-opts}]
  (let [run-opts' (merge default-run-opts run-opts)]
    (util/set-logging-config! (cli/parse-opts main-args))
    (cli/dispatch (full-commands run-opts') main-args {})))

(defn -main [& args]
  (bbin args))

(when (= *file* (System/getProperty "babashka.file"))
  (util/check-min-bb-version)
  (apply -main *command-line-args*))
