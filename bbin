#!/usr/bin/env bb

; :bbin/start
;
; {:coords {:bbin/url "https://raw.githubusercontent.com/rads/bbin/main/bbin"}}
;
; :bbin/end

(babashka.deps/add-deps
  '{:deps {org.babashka/cli {:mvn/version "0.3.35"},
           org.clojure/core.async {:mvn/version "1.5.648"},
           babashka/process {:mvn/version "0.1.7"},
           fipp/fipp {:mvn/version "0.6.26"},
           mvxcvi/puget {:mvn/version "1.3.2"},
           com.taoensso/timbre {:mvn/version "5.2.1"},
           selmer/selmer {:mvn/version "1.12.53"}}})

(ns rads.bbin.trust
  (:require [clojure.string :as str]))

(def allow-list
  {'babashka {}
   'rads {}})

(defn allowed-url? [url]
  (some #(or (str/starts-with? url (str "https://github.com/" % "/"))
             (str/starts-with? url (str "https://gist.githubusercontent.com/" % "/")))
        (keys allow-list)))

(ns rads.bbin.curl
  (:require
    [babashka.curl :as curl]
    [babashka.fs :as fs]
    [cheshire.core :as cheshire]))

(import java.net.URLEncoder)

(defn url-encode [s] (URLEncoder/encode s "UTF-8"))

(def curl-opts
  {:throw false
   :compressed (not (fs/windows?))})

(defn curl-get-json [url]
  (-> (curl/get url curl-opts)
      :body (cheshire/parse-string true)))

(ns rads.bbin.git
  (:require [rads.bbin.curl :refer [curl-get-json]]
            [clojure.string :as str]))

(defn default-branch [lib]
  (get (curl-get-json (format "https://api.github.com/repos/%s/%s"
                              (namespace lib) (name lib)))
       :default_branch))

(defn clean-github-lib [lib]
  (let [lib (str/replace lib "com.github." "")
        lib (str/replace lib "io.github." "")
        lib (symbol lib)]
    lib))

(defn latest-github-sha [lib]
  (let [lib (clean-github-lib lib)
        branch (default-branch lib)]
    (get (curl-get-json (format "https://api.github.com/repos/%s/%s/commits/%s"
                                (namespace lib) (name lib) branch))
         :sha)))

(defn list-github-tags [lib]
  (let [lib (clean-github-lib lib)]
    (curl-get-json (format "https://api.github.com/repos/%s/%s/tags"
                           (namespace lib) (name lib)))))

(defn latest-github-tag [lib]
  (-> (list-github-tags lib)
      first))

(defn find-github-tag [lib tag]
  (->> (list-github-tags lib)
       (filter #(= (:name %) tag))
       first))

(ns rads.bbin.infer
  (:require [rads.bbin.git :as git]
            [clojure.edn :as edn]
            [clojure.set :as set]))

(defn- github-repo-http-url [lib]
  (str "https://github.com/" (git/clean-github-lib lib)))

(def github-repo-ssh-regex #"^git@github.com:([^/]+)/([^\.]+)\.git$")
(def github-repo-http-regex #"^https://github.com/([^/]+)/([^\.]+)(\.git)?$")

(defn- parse-git-url [git-url]
  (let [[[_ gh-user repo-name]] (or (re-seq github-repo-ssh-regex git-url)
                                    (re-seq github-repo-http-regex git-url))]
    (if (and gh-user repo-name)
      {:gh-user gh-user :repo-name repo-name}
      (throw (ex-info "Failed to parse :git/url" {:git/url git-url})))))

(defn- git-url->lib-sym [git-url]
  (when-let [{:keys [gh-user repo-name]} (parse-git-url git-url)]
    (symbol (str "io.github." gh-user) repo-name)))

(def lib-opts->template-deps-fn
  "A map to define valid CLI options.

  - Each key is a sequence of valid combinations of CLI opts.
  - Each value is a function which returns a tools.deps lib map."
  {[#{:local/root}]
   (fn [lib-sym lib-opts]
     {lib-sym (select-keys lib-opts [:local/root])})

   [#{} #{:git/url}]
   (fn [lib-sym lib-opts]
     (let [url (or (:git/url lib-opts) (github-repo-http-url lib-sym))
           {:keys [name commit]} (git/latest-github-tag (git-url->lib-sym url))]
       {lib-sym {:git/url url :git/tag name :git/sha (:sha commit)}}))

   [#{:git/tag} #{:git/url :git/tag}]
   (fn [lib-sym lib-opts]
     (let [url (or (:git/url lib-opts) (github-repo-http-url lib-sym))
           tag (:git/tag lib-opts)
           {:keys [commit]} (git/find-github-tag (git-url->lib-sym url) tag)]
       {lib-sym {:git/url url :git/tag tag :git/sha (:sha commit)}}))

   [#{:git/sha} #{:git/url :git/sha}]
   (fn [lib-sym lib-opts]
     (let [url (or (:git/url lib-opts) (github-repo-http-url lib-sym))
           sha (:git/sha lib-opts)]
       {lib-sym {:git/url url :git/sha sha}}))

   [#{:latest-sha} #{:git/url :latest-sha}]
   (fn [lib-sym lib-opts]
     (let [url (or (:git/url lib-opts) (github-repo-http-url lib-sym))
           sha (git/latest-github-sha (git-url->lib-sym url))]
       {lib-sym {:git/url url :git/sha sha}}))

   [#{:git/url :git/tag :git/sha}]
   (fn [lib-sym lib-opts]
     {lib-sym (select-keys lib-opts [:git/url :git/tag :git/sha])})})

(def valid-lib-opts
  "The set of all valid combinations of CLI opts."
  (into #{} cat (keys lib-opts->template-deps-fn)))

(defn- cli-opts->lib-opts
  "Returns parsed lib opts from raw CLI opts."
  [cli-opts]
  (-> cli-opts
      (set/rename-keys {:sha :git/sha})
      (select-keys (into #{} cat valid-lib-opts))))

(defn- find-template-deps-fn
  "Returns a template-deps-fn given lib-opts parsed from raw CLI opts."
  [lib-opts]
  (some (fn [[k v]] (and (contains? (set k) (set (keys lib-opts))) v))
        lib-opts->template-deps-fn))

(defn- invalid-lib-opts-error [provided-lib-opts]
  (ex-info (str "Provided invalid combination of CLI options")
           {:provided-opts (set (keys provided-lib-opts))
            :valid-combinations valid-lib-opts}))

(defn resolve-deps
  "Returns a tools.deps lib map for the given CLI opts."
  [template cli-opts]
  (let [lib-opts (cli-opts->lib-opts cli-opts)
        lib-sym (edn/read-string template)
        template-deps-fn (find-template-deps-fn lib-opts)]
    (if-not template-deps-fn
      (throw (invalid-lib-opts-error lib-opts))
      (template-deps-fn lib-sym lib-opts))))

(ns rads.bbin
  (:require [babashka.fs :as fs]
            [babashka.cli :as cli]
            [babashka.deps :as deps]
            [babashka.process :refer [sh]]
            [rads.bbin.infer :as infer]
            [clojure.string :as str]
            [taoensso.timbre :as log]
            [clojure.edn :as edn]
            [clojure.pprint :as pprint]
            [selmer.parser :as selmer]
            [selmer.util :as selmer-util]
            [rads.bbin.git :as git]
            [rads.bbin.trust :as trust]))

(defn bbin-root [cli-opts]
  (str (or (some-> (:bbin/root cli-opts) (fs/canonicalize {:nofollow-links true}))
           (fs/expand-home "~/.bbin"))))

(defn bin-dir [cli-opts]
  (fs/file (bbin-root cli-opts) "bin"))

(defn pprint [x _]
  (pprint/pprint x))

(defn print-help [_]
  (println (str/trim "
Usage: bbin <command>

  bbin install    Install a script
  bbin uninstall  Remove a script
  bbin ls         List installed scripts
  bbin bin        Display bbin bin folder")))

(declare print-commands)

(defn gitlib-path [cli-opts script-deps]
  (let [coords (val (first script-deps))]
    (fs/expand-home (str "~/.gitlibs/libs/" (:script/lib cli-opts) "/" (:git/sha coords)))))

(def git-or-local-template-str
  "#!/usr/bin/env bash
set -e

# :bbin/start
#
{{script/meta}}
#
# :bbin/end

SCRIPT_ROOT='{{script/root}}'
SCRIPT_LIB='{{script/lib}}'
SCRIPT_COORDS='{{script/coords}}'
SCRIPT_MAIN_OPTS_FIRST='{{script/main-opts.0}}'
SCRIPT_MAIN_OPTS_SECOND='{{script/main-opts.1}}'

exec bb \\
  --deps-root \"$SCRIPT_ROOT\" \\
  --config <(echo \"{:deps {$SCRIPT_LIB $SCRIPT_COORDS}}\") \\
  $SCRIPT_MAIN_OPTS_FIRST \"$SCRIPT_MAIN_OPTS_SECOND\" \\
  -- \"$@\"")

(defn ensure-bbin-dirs [cli-opts]
  (fs/create-dirs (bin-dir cli-opts)))

(defn- http-url->script-name [http-url]
  (first
    (str/split (last (str/split http-url #"/"))
               #"\.")))

(defn bb-shebang? [s]
  (str/starts-with? s "#!/usr/bin/env bb"))

(defn insert-script-header [script-contents header]
  (let [
        prev-lines (str/split-lines script-contents)
        [prefix [shebang & code]] (split-with #(not (bb-shebang? %)) prev-lines)
        next-lines (concat prefix [shebang]
                           [""
                            "; :bbin/start"
                            ";"]
                           (map #(str "; " %)
                                (str/split-lines
                                  (with-out-str
                                    (pprint/pprint header))))
                           [";"
                            "; :bbin/end"]
                           code)]
    (str/join "\n" next-lines)))

(defn run-install-http [cli-opts]
  (if-not (trust/allowed-url? (:script/lib cli-opts))
    (throw (ex-info (str "Script URL is not trusted") {:untrusted-url (:script/lib cli-opts)}))
    (let [http-url (:script/lib cli-opts)
          script-deps {:bbin/url http-url}
          header {:coords script-deps}
          _ (pprint header cli-opts)
          script-name (or (:as cli-opts) (http-url->script-name http-url))
          script-contents (-> (slurp (:bbin/url script-deps))
                              (insert-script-header header))
          script-file (fs/canonicalize (fs/file (bin-dir cli-opts) script-name)
                                       {:nofollow-links true})]
      (if (:dry-run cli-opts)
        (pprint {:script-file (str script-file)
                 :script-contents script-contents}
                cli-opts)
        (do
          (spit (str script-file) script-contents)
          (sh ["chmod" "+x" (str script-file)] {:err :inherit})
          nil)))))

(defn default-git-or-local-script-config [cli-opts]
  (let [[ns name] (str/split (:script/lib cli-opts) #"/")]
    {:main-opts ["-m" (str (git/clean-github-lib ns) "." name)]}))

(defn run-install-deps-git-or-local [cli-opts]
  (let [script-deps (infer/resolve-deps (:script/lib cli-opts) cli-opts)
        header {:lib (key (first script-deps))
                :coords (val (first script-deps))}
        _ (pprint header cli-opts)
        _ (deps/add-deps {:deps script-deps})
        script-root (fs/canonicalize (or (:local/root cli-opts) (gitlib-path cli-opts script-deps)) {:nofollow-links true})
        bb-edn (some-> (fs/file script-root "bb.edn") slurp edn/read-string)
        script-name (or (:as cli-opts)
                        (some-> (:bbin/bin bb-edn) first key str)
                        (second (str/split (:script/lib cli-opts) #"/")))
        script-config (or (some-> (:bbin/bin bb-edn) first val)
                          (default-git-or-local-script-config cli-opts))
        script-edn-out (with-out-str
                          (binding [*print-namespace-maps* false]
                            (clojure.pprint/pprint header)))
        main-opts (or (some-> (:main-opts cli-opts) edn/read-string)
                      (:main-opts script-config))
        template-opts {:script/meta (->> script-edn-out
                                          str/split-lines
                                          (map #(str "# " %))
                                          (str/join "\n"))
                       :script/root script-root
                       :script/lib (pr-str (key (first script-deps)))
                       :script/coords (binding [*print-namespace-maps* false] (pr-str (val (first script-deps))))
                       :script/main-opts [(first main-opts)
                                          (if (= "-f" (first main-opts))
                                            (fs/canonicalize (fs/file script-root (second main-opts))
                                                             {:nofollow-links true})
                                            (second main-opts))]}
        template-out (selmer-util/without-escaping
                       (selmer/render git-or-local-template-str template-opts))
        script-file (fs/canonicalize (fs/file (bin-dir cli-opts) script-name) {:nofollow-links true})]
    (if (:dry-run cli-opts)
      (pprint {:script-file (str script-file)
               :template-out template-out}
              cli-opts)
      (do
        (spit (str script-file) template-out)
        (sh ["chmod" "+x" (str script-file)] {:err :inherit})
        nil))))

(def maven-template-str
  "#!/usr/bin/env bash
set -e

# :bbin/start
#
{{script/meta}}
#
# :bbin/end

SCRIPT_LIB='{{script/lib}}'
SCRIPT_COORDS='{{script/coords}}'
SCRIPT_MAIN_OPTS_FIRST='{{script/main-opts.0}}'
SCRIPT_MAIN_OPTS_SECOND='{{script/main-opts.1}}'

exec bb \\
  --config <(echo \"{:deps {$SCRIPT_LIB $SCRIPT_COORDS}}\") \\
  $SCRIPT_MAIN_OPTS_FIRST \"$SCRIPT_MAIN_OPTS_SECOND\" \\
  -- \"$@\"")

(defn default-maven-script-config [cli-opts]
  (let [[ns name] (str/split (:script/lib cli-opts) #"/")
        top (last (str/split ns #"\."))]
    {:main-opts ["-m" (str top "." name)]}))

(defn run-install-deps-maven [cli-opts]
  (let [script-deps {(edn/read-string (:script/lib cli-opts))
                     (select-keys cli-opts [:mvn/version])}
        header {:lib (key (first script-deps))
                :coords (val (first script-deps))}
        _ (pprint header cli-opts)
        _ (deps/add-deps {:deps script-deps})
        script-root (fs/canonicalize (or (:local/root cli-opts) (gitlib-path cli-opts script-deps)) {:nofollow-links true})
        script-name (or (:as cli-opts) (second (str/split (:script/lib cli-opts) #"/")))
        script-config (default-maven-script-config cli-opts)
        script-edn-out (with-out-str
                         (binding [*print-namespace-maps* false]
                           (clojure.pprint/pprint header)))
        main-opts (or (some-> (:main-opts cli-opts) edn/read-string)
                      (:main-opts script-config))
        template-opts {:script/meta (->> script-edn-out
                                         str/split-lines
                                         (map #(str "# " %))
                                         (str/join "\n"))
                       :script/root script-root
                       :script/lib (pr-str (key (first script-deps)))
                       :script/coords (binding [*print-namespace-maps* false] (pr-str (val (first script-deps))))
                       :script/main-opts [(first main-opts)
                                          (if (= "-f" (first main-opts))
                                            (fs/canonicalize (fs/file script-root (second main-opts))
                                                             {:nofollow-links true})
                                            (second main-opts))]}
        template-out (selmer-util/without-escaping
                       (selmer/render maven-template-str template-opts))
        script-file (fs/canonicalize (fs/file (bin-dir cli-opts) script-name) {:nofollow-links true})]
    (if (:dry-run cli-opts)
      (pprint {:script-file (str script-file)
               :template-out template-out}
              cli-opts)
      (do
        (spit (str script-file) template-out)
        (sh ["chmod" "+x" (str script-file)] {:err :inherit})
        nil))))

(defn run-install [parsed-args]
  (if-not (get-in parsed-args [:opts :script/lib])
    (print-help parsed-args)
    (do
      (ensure-bbin-dirs (:opts parsed-args))
      (let [cli-opts (merge (:opts parsed-args)
                            (when-let [v (:local/root (:opts parsed-args))]
                              {:local/root (str (fs/canonicalize v {:nofollow-links true}))}))]
        (cond
          (re-seq #"^https?://" (:script/lib cli-opts))
          (run-install-http cli-opts)

          (:mvn/version cli-opts)
          (run-install-deps-maven cli-opts)

          :else
          (run-install-deps-git-or-local cli-opts))))))

(defn run-uninstall [parsed-args]
  (if-not (get-in parsed-args [:opts :script/lib])
    (print-help parsed-args)
    (do
      (ensure-bbin-dirs (:opts parsed-args))
      (let [cli-opts (:opts parsed-args)
            script-name (:script/lib cli-opts)
            script-file (fs/canonicalize (fs/file (bin-dir cli-opts) script-name) {:nofollow-links true})]
        (when (fs/delete-if-exists script-file)
          (println "Removing" (str script-file)))))))

(defn parse-script [s]
  (let [lines (str/split-lines s)
        prefix (if (str/ends-with? (first lines) "bb") ";" "#")]
    (->> lines
         (drop-while #(not (re-seq (re-pattern (str "^" prefix " *:bbin/start")) %)))
         next
         (take-while #(not (re-seq (re-pattern (str "^" prefix " *:bbin/end")) %)))
         (map #(str/replace % (re-pattern (str "^" prefix " *")) ""))
         (str/join "\n")
         edn/read-string)))

(defn load-scripts [cli-opts]
  (->> (file-seq (bin-dir cli-opts))
       (filter #(.isFile %))
       (map (fn [x] [(symbol (str (fs/relativize (bin-dir cli-opts) x)))
                     (parse-script (slurp x))]))
       (into {})))

(defn run-ls [{:keys [opts]}]
  (pprint (load-scripts opts) opts))

(defn run-bin [{:keys [opts]}]
  (println (str (bin-dir opts))))

(def commands
  [{:cmds ["commands"] :fn #(print-commands %)}
   {:cmds ["help"] :fn print-help}
   {:cmds ["install"] :fn run-install :args->opts [:script/lib]}
   {:cmds ["uninstall"] :fn run-uninstall :args->opts [:script/lib]}
   {:cmds ["ls"] :fn run-ls}
   {:cmds ["bin"] :fn run-bin}
   {:cmds [] :fn print-help :aliases {:h :help}}])

(defn print-commands [_]
  (println (str/join " " (keep #(first (:cmds %)) commands)))
  nil)

(defn set-logging-config! [{:keys [debug]}]
  (log/merge-config! {:min-level (if debug :debug :warn)}))

(defn -main [& args]
  (set-logging-config! (cli/parse-opts args))
  (cli/dispatch commands args {}))

(when (= *file* (System/getProperty "babashka.file"))
  (apply -main *command-line-args*))

(comment
  (-main "help")
  (-main "install" "https://raw.githubusercontent.com/babashka/babashka/master/examples/portal.clj"))
